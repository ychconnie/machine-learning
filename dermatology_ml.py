# -*- coding: utf-8 -*-
"""Dermatology_ML

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YyDCdVU7a7SM0c9i02X0Hvx1YXktgQ5Z
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn import tree
from sklearn.metrics import accuracy_score, confusion_matrix
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt
from sklearn.cluster import AgglomerativeClustering, KMeans
from sklearn.preprocessing import StandardScaler
import scipy.cluster.hierarchy as sch

dermatology=pd.read_csv("/Users/yichinhuang/Downloads/dermatology.csv",sep="\t")
print(dermatology)
dermatology.dtypes
#replace the ? with 0
dermatology["Age"]=dermatology["Age"].replace("?",0).astype("int")
dermatology.dtypes
#replace the 0 with mean(age)
dermatology["Age"]=dermatology["Age"].replace(0,np.mean(dermatology["Age"]))

"""## Gradient Descent (Model 1)"""

X=dermatology["Age"].values.reshape(-1,1)
y=dermatology["Disease"].values.reshape(-1,1)

#epsilon: the amount of change that constrain us from doing forever
# X: mxn, y: mx1, Theta: nx1
def grad_descent(X, y, alpha, epsilon):
    iteration=[0]
    i=0
    m=np.shape(X)[0] #total number of samples

    #initialize the model
    Theta=np.random.randn(X.shape[1],1)*0.01

    #compute the initial cost
    cost=[1/(2*m)*np.transpose(X@Theta-y)@(X@Theta-y)]
    delta=1

    #keep going unitl the change in the model is big enough->loop
    #if the subsequent cost is going up, should stop
    while (delta>epsilon):
        gradient=(1/m)*(np.transpose(X)@(X@Theta-y))
        Theta=Theta - alpha*gradient
        J_Theta=1/(2*m)*(np.transpose(X@Theta-y)@(X@Theta-y))
        #print(J_Theta)
        cost.append(J_Theta)
        delta=abs(cost[i+1][0,0]-cost[i][0,0])
        if ((cost[i+1][0,0]-cost[i][0,0]>0)):
            print("The cost is increasing. DO SOMETHING")
            break
        i+=1
        iteration.append(i)

    print("Complete in %d iterations."%(i))
    return(Theta,iteration,cost)

# Add a column of ones to X to account for the intercept term
# really small eppsilon: don't have much tolerance for errors
X=np.concatenate([np.ones((X.shape[0],1)), X], axis=1)

Theta,iterations,cost=grad_descent(X, y, 0.0000001, 10**-7)
print(Theta)

"""## Random Forest (Model 2)"""

from sklearn.ensemble import RandomForestClassifier
X=dermatology.drop(columns="Disease")
y=dermatology["Disease"]
accuracy_list=[]
#run the model 50 times
for i in range(50):
  X_train, X_test, y_train, y_test=train_test_split(X,y,test_size=0.3,random_state=i)
  rf=RandomForestClassifier(n_estimators=100)
  rf.fit(X_train,y_train)
  predictions_rf=rf.predict(X_test)
  accuracy=accuracy_score(y_test,predictions_rf)
  accuracy_list.append(accuracy)
print(np.mean(accuracy_list))
#print(confusion_matrix(y_test,predictions_rf))

"""## kNN (Model 3)"""

from sklearn.neighbors import KNeighborsClassifier
X=dermatology.drop(columns="Disease")
y=dermatology["Disease"]

accuracy_ave=np.zeros(50)
#run the model 50 times
for k in range(50):
  X_train, X_test, y_train, y_test=train_test_split(X,y,test_size=0.3,random_state=k)
  classifier=KNeighborsClassifier(n_neighbors=6)
  classifier.fit(X_train,y_train)
  predictions_knn=classifier.predict(X_test)
  #print(predictions_knn)

  accuracy_ave[k]=np.where(predictions_knn==y_test,1,0).sum()/len(y_test)
accuracy_score=np.mean(accuracy_ave)
print("average_accuracy=",accuracy_score)

"""## Aggelomerative clustering (Model 4)"""

from sklearn.preprocessing import StandardScaler
import scipy.cluster.hierarchy as sch
der=dermatology.drop(columns="Disease")
scaler=StandardScaler()
scaler.fit_transform(der)
#print(der)

linkage_matrix=sch.linkage(der,method="complete")
a_cluster=AgglomerativeClustering(n_clusters=6,linkage="complete")
predictions_ac=a_cluster.fit_predict(der)
print(predictions_ac)

correct=np.where(dermatology["Disease"]==predictions_ac,1,0).sum()
correct_list=[]
for i in range(len(predictions_ac)):
  if predictions_ac[i]==dermatology["Disease"][i]:
    correct_list.append([i,predictions_ac[i]])
#print(correct_list)
#print(len(correct_list))
accuracy_ac=correct/len(dermatology["Disease"])
#print(dermatology["Disease"])
print(accuracy_ac)

#plot the dendrogram
plt.figure(figsize=(20,6))
dendogram_p1=sch.dendrogram(linkage_matrix)
plt.ylabel("height")
plt.savefig("dendogram.png",dpi=300)
#plt.xticks(rotation=270)
plt.title("Dendrogram of Agglomerative Clustering")
plt.show()

"""## Divisive Clustering (Model 5)"""

X=der.iloc[:,:]

correct_all=np.zeros(50)

for i in range(50):
  kmeans=KMeans(n_clusters=6,random_state=i)
  y_means=kmeans.fit_predict(X)
  correct_all[i]=np.where(y_means==dermatology["Disease"],1,0).sum()/len(der)
  #print(correct_all[i])
#accuracy_dc=correct_all/len(dermatology["Disease"])
accuracy_dc=np.mean(correct_all)
print(accuracy_dc)
print(y_means)
print(pd.DataFrame([dermatology["Disease"],y_means]))